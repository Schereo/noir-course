{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"2525890185759478415","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"_recipient","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_proof","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"is_even","type":{"kind":"array","length":20,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{"13687630160716619492":{"error_kind":"string","string":"Computed root does not match the provided root"}}},"bytecode":"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","debug_symbols":"pdfdauswDAfwd8l1LyzZku29yuEwsi4bgZCWrB0cxt79uO1f/YA5dM2V1Gb61XEks3w1r93L/v25H982H83Tn6/mZeqHoX9/HjbrdtdvxvLt1/eqsY/Pu6nrylfN1fVStW2nbtw1T+N+GFbNZzvsj3/0sW3HY9y1U7nqVk03vpZYwLd+6A7Z9+pS7eqlPiqKA8m5XG7raaZe+Fyvl/p0U8/1euaUAbB3XBN8XSBSWwJRkkfWEMk2gaN3NUFm1hCjtzXEXL0LrQs5CIBcin5fT47Pu+BUHrmH7OxJUObqPcz0UpBkvZBytZfcwmaimW5kTTYLrNlXiZlmIH/ZBs/VR0F+4bOc3YecfhrKX+zDfR1NurilKS7uydlVLG5KcbYGCb7WlHP10Z6FhuoByXMnJNkC/PUN0P1AsBV49Y8AQW0oQq4DYekhL4tPedblx7wsngpOi6eC88LTYQ64c6xmb2PxWOn5rNd4e9b/LZ/adT/d/KfTsGueSgXTKfAp+PL7hxgQpSy7/CjrYWxKjIgJMZ+id4iEyIgeMSAKIjwPz8Pz8AK8AC/AC/ACvAAvwAvwArwAT+AJPIEn8ASewBN4Ak/gCTyFp/AUnsJTeApP4Sk8hafwIrwIL8KL8CK8CC/Ci/AivAgvwUvwErwEL8FL8BK8BC/BS/AyvAwvw8vwMrwML8PL8DK8DI+cs4QsYUu8JcESsUQtiZYkS0wmk8lkMplMJpPJZDKZTCaTyWQ2mU1mk9lkNplNPo7O4ZD/bKe+fRk6vGe87cf11WvH7t/WrtiLyXbarLvX/dQdBvd4rYzyfw==","file_map":{"50":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nmod merkle_tree;\n\nfn main(\n    // Public inputs\n    root: pub Field,\n    nullifier_hash: pub Field,\n    _recipient: pub Field,\n    // Private inputs\n    nullifier: Field,\n    secret: Field,\n    merkle_proof: [Field; 20],\n    is_even: [bool; 20]\n) {\n    // compute the commitment Poseidon(nullifier, secret)\n    let commitment: Field = Poseidon2::hash([nullifier, secret], 2);\n    let computed_nullifier_hash: Field = Poseidon2::hash([nullifier], 1);\n    assert(computed_nullifier_hash == nullifier_hash);\n\n    let computed_root: Field = merkle_tree::compute_merkle_root(commitment, merkle_proof, is_even);\n    assert(computed_root == root, \"Computed root does not match the provided root\");\n}","path":"/Users/tim/Documents/tim-repo/noir-course/zk_mixer/circuits/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\n\npub fn compute_merkle_root(\n    leaf: Field,\n     merkle_proof: [Field; 20],\n      is_even: [bool; 20]\n      ) -> Field {\n        let mut hash: Field = leaf;\n        // Increment through the levels of the tree\n        for i in 0..20 {\n            let (left, right) = if is_even[i] {\n                (hash, merkle_proof[i])\n            } else {\n                (merkle_proof[i], hash)\n            };\n            hash = Poseidon2::hash([left, right], 2);\n        }\n        hash\n      }\n","path":"/Users/tim/Documents/tim-repo/noir-course/zk_mixer/circuits/src/merkle_tree.nr"},"58":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/tim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":[]}